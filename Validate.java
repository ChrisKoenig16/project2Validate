package cmsc433;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import cmsc433.SimulationEvent;

/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {

		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() {
		}
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			throw new Validate.InvalidSimulationException();
		}
	}


	/*
	 * this method checks that these conditions are true ->
	 * 
	 * The capacity of each machine should not be exceeded
	 * Eater should not receive order until cook completes it
	 * Eater should not leave Ratsie's until order is received
	 * Eater should not place more than one order
	 * Cook should not work on order before it is placed
	 */
	// 1. customer places order
	// 2. cook receives order
	// 3. cooks completes order
	// 4. customer receives order
	// 5. customer leaves ratsie
	// ensure this ordering for every customer

	private static boolean checkOrdering(List<SimulationEvent> events) {
		int numCustomers = events.get(0).simParams[0];
		SimulationEvent curEvent;
		HashSet<Integer> orderSet = new HashSet<Integer>();
		int start = 0;
		int validateIndex = 0;
		int correctOrderings = 0;
		Customer curCustomer;
		// the correct ordering of the events
		SimulationEvent.EventType[] validate = new SimulationEvent.EventType[] {
				SimulationEvent.EventType.CustomerPlacedOrder,
				SimulationEvent.EventType.CookReceivedOrder,
				SimulationEvent.EventType.CookCompletedOrder,
				SimulationEvent.EventType.CustomerReceivedOrder,
				SimulationEvent.EventType.CustomerLeavingRatsies};
		

		for(int i = 1; i < events.size(); i++) {
			curEvent = events.get(i);
			// if you find an order placed event start searching for the next event
			if(curEvent.event == SimulationEvent.EventType.CustomerPlacedOrder) {
				start = i;
				curCustomer = curEvent.customer;
				// check for duplicate orders 
				if(orderSet.contains(curEvent.orderNumber)) {
					return false;
				}
				// loop through the  rest of the events looking for the next event that also has the correct order number
				for(int j=start; j < events.size(); j++) {
					SimulationEvent temp = events.get(j);
					if(validateIndex != 5 && temp.event == validate[validateIndex]) {
						// if the event is customer leaving you cant compare via order number because its not included in the event
						// and you cant compare via the customers order number field because that shit is private so i use toString()
						// to avoid that (you could just write a getter or make it public)
						if(validateIndex == 4 && temp.customer.toString().equals(curCustomer.toString())) {
							validateIndex++;
						}
						else if(temp.orderNumber == curEvent.orderNumber) {
							validateIndex++;
						}
					}
				}
				// check that you found all 5 matching events in the correct order
				if(validateIndex != 5) {
					return false;
				}
				else {correctOrderings++;}
			}

		}
		if(correctOrderings != numCustomers) {
			return false;
		}
		return true;

	}
	/**
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *        in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 * 
	 */

	/* 
	 * This method checks these conditions ->
	 * 
	 * Should not have more eaters than specified
	 * Should not have more cooks than specified
	 * The Ratsie's capacity should not be exceeded
	 * The capacity of each machine should not be exceeded
	 */
	private static boolean checkParams(List<SimulationEvent> events) {
		int[] params = events.get(0).simParams;
		int numCustomers = params[0]; 
		int numCooks = params[1];
		int numTables = params[2];
		int machineCount = params[3];
		int[] machineCapacities = new int[4];
		int curCustomers = 0;
		int curCooks = 0;
		int curCapacity = 0;



		SimulationEvent curEvent;
		for(int i = 1; i < events.size(); i++) {
			curEvent = events.get(i);
			switch(curEvent.event) {
			case CustomerStarting:
				curCustomers++;
				break;
			case CookStarting:
				curCooks++;
				break;
			case CustomerEnteredRatsies:
				curCapacity++;
				break;
			case CustomerLeavingRatsies:
				curCapacity--;
				break;
			case MachinesStartingFood:
				machineCapacities[curEvent.machines.machineType.ordinal()]++;
				break;
			case MachinesDoneFood:
				machineCapacities[curEvent.machines.machineType.ordinal()]--;
				break;
			default:
				break;
			}
			if(curCustomers > numCustomers || curCooks > numCooks || curCapacity > numTables) {
				return false;
			}
			for(int m : machineCapacities) {
				if(m > machineCount) {
					return false;
				}
			}
		}
		return true;
	}

	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size() - 1).event == SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			// this is my method
			check(checkParams(events), "you exceeded capacity in machines/cooks/customers/eaters");
			check(checkOrdering(events),"some of your events were out of order");

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}

	}
}
